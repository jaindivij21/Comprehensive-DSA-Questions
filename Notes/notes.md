# Comprehensive DSA & Algorithms Preparation Plan

## Overview
This preparation plan is structured in two phases:
- **Phase 1**: Topic-wise learning and practice (NeetCode Roadmap)
- **Phase 2**: Thorough practice (Sean Prashad's Patterns + Codeforces)

## Phase 1: Topic-wise Learning (NeetCode Roadmap)

### Study Methodology for Each Topic:
1. **Theory Study**: Read from Introduction to Algorithms + Cracking the Coding Interview
2. **Other Learning**: Watch specific resources from comprehensive guide (https://leetcode.com/discuss/post/494279/comprehensive-data-structure-and-algorit-tdez/)
3. **Practical Implementation**: Code basic implementations and notes from my repo.
4. **Note Creation**: Write topic summary with key concepts, patterns, and templates
5. **Problem Practice**: Solve all NeetCode problems for the topic (https://neetcode.io/roadmap)
6. **Review Session**: Revisit difficult problems and edge cases


### Phase 1 Topics:

#### Arrays & Hashing
**Key Patterns**: Hash map usage, frequency arrays, two-pass vs one-pass solutions

#### Two Pointers
**Key Patterns**: Opposite direction pointers, same direction pointers, cycle detection

#### Sliding Window
**Key Patterns**: Maximum/minimum window, substring matching, optimization problems

#### Stack
**Key Patterns**: Next greater/smaller element, balanced parentheses, function call simulation

#### Queue
**Key Patterns**: FIFO operations, BFS implementation, circular queue, priority queue basics

#### Recursion
**Key Patterns**: Base case identification, recursive case formulation, memoization basics

#### Sorting Algorithms
**Key Patterns**: 
- Comparison-based sorts (Merge Sort, Quick Sort, Heap Sort)  
- Non-comparison sorts (Counting Sort, Radix Sort, Bucket Sort)
- Stability and in-place properties
- Custom comparators

#### Binary Search
**Key Patterns**: Search in sorted arrays, optimization problems, finding boundaries, binary search on answer

#### Linked List
**Key Patterns**: Two-pointer technique, dummy node usage, in-place operations, cycle detection

#### Trees
**Key Patterns**: Recursive tree problems, level-by-level processing, ancestor-descendant relationships

#### Binary Search Trees
**Key Patterns**: BST property validation, insertion/deletion, inorder traversal, balanced BSTs

#### AVL Trees
**Key Patterns**: Self-balancing BST, rotation operations, height balance factor, insertion/deletion with rebalancing

#### Red-Black Trees
**Key Patterns**: Self-balancing BST with color properties, insertion/deletion with color fixes, rotation and recoloring

#### Tries (Prefix Trees)
**Key Patterns**: Prefix-based searches, word games, autocomplete systems, dictionary operations

#### Heap / Priority Queue
**Key Patterns**: Top/bottom K elements, scheduling problems, streaming data, heap operations

#### Union Find (Disjoint Set Union)
**Key Patterns**: Connected components, cycle detection in undirected graphs, dynamic connectivity, path compression, union by rank

#### Backtracking
**Key Patterns**: Generate all possibilities, constraint checking, early termination, pruning

#### Dynamic Programming
**Key Patterns**: 
- Linear DP (climbing stairs, house robber)
- Grid DP (paths, minimum cost)
- String DP (edit distance, palindromes)
- Subsequence DP (LIS, LCS)
- Partition DP (palindrome partitioning)
- State machine DP (buy/sell stocks)
- Tree DP
- Bitmask DP

#### Greedy Algorithms
**Key Patterns**: Interval scheduling, fractional problems, optimization with constraints, activity selection

#### Intervals
**Key Patterns**: Meeting rooms, calendar scheduling, interval merging, sweep line algorithm

#### Graphs - Basic
**Key Patterns**: Graph traversal (DFS, BFS), connectivity problems, dependency resolution, graph representation

#### Graphs - Advanced
**Key Patterns**: 
- Shortest paths (Dijkstra, Bellman-Ford, Floyd-Warshall)
- Minimum spanning tree (Kruskal, Prim)
- Strongly connected components (Kosaraju, Tarjan)
- Articulation points and bridges

#### Topological Sort
**Key Patterns**: Dependency resolution, course scheduling, build order problems, Kahn's algorithm

#### Minimum Spanning Tree
**Key Patterns**: Kruskal's algorithm, Prim's algorithm, network connectivity, cycle property

#### String Algorithms
**Key Patterns**:
- Pattern matching (KMP, Rabin-Karp)
- String manipulation and processing
- Palindrome detection
- Anagram problems
- Substring search

#### Bit Manipulation
**Key Patterns**: Single number problems, counting bits, bit masking, XOR properties, bit tricks

#### Math & Geometry
**Key Patterns**: 
- Mathematical computations, geometric transformations
- Basic coordinate geometry
- Prime numbers and factorization
- GCD and LCM
- Modular arithmetic

#### Divide and Conquer
**Key Patterns**: Problem decomposition, combining solutions, recursive problem solving

#### Segment Trees
**Key Patterns**: Range queries, point updates, lazy propagation

#### Fenwick Tree (Binary Indexed Tree)
**Key Patterns**: Prefix sum queries, range sum updates, cumulative frequency

#### Hashing Techniques
**Key Patterns**: 
- Rolling hash, polynomial hashing
- Hash functions and collision handling
- Hash tables implementation

#### Game Theory (Basic)
**Key Patterns**: 
- Nim games
- Minimax algorithm
- Optimal strategy problems

#### Number Theory (Basic)
**Key Patterns**: 
- Prime numbers and sieve algorithms
- GCD and LCM, Extended Euclidean Algorithm
- Modular arithmetic, modular exponentiation

#### Combinatorics (Basic)
**Key Patterns**: 
- Permutations, combinations, counting problems
- Basic probability
- Catalan numbers


## Phase 2: Pattern-based Practice
1. Sean Prashad's LeetCode Patterns (https://seanprashad.com/leetcode-patterns/):
2. Codeforces 
